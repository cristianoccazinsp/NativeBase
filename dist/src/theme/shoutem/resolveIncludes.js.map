{"version":3,"sources":["../../../../src/theme/shoutem/resolveIncludes.js"],"names":["INCLUDE","includeSymbolMergeHandler","objVal","srcVal","newObjVal","include","_","isUndefined","isPlainObject","newObj","mergeWith","o","s","resolveIncludes","target","base","getStyle","styleName","defaultStyle","style","baseStyle","Error","targetStyle","console","warn","includeNodeStyles","styleNode","processingStyleNames","styleNamesToInclude","stylesToInclude","isArray","has","add","delete","resultingStyle","Object","keys","Set"],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nexport const INCLUDE = '@@shoutem.theme/include';\n\n/**\n * Customizer function for lodash mergeWith which handle INCLUDE symbol.\n * Lodash merge/mergeWith functions doesn't merge symbols\n * and we use INCLUDE symbol to define which style we want to include.\n */\nfunction includeSymbolMergeHandler(objVal, srcVal) {\n  const newObjVal = objVal;\n  let include;\n\n  if (srcVal && srcVal[INCLUDE]) {\n    include =\n      newObjVal && newObjVal[INCLUDE]\n        ? [...newObjVal[INCLUDE], ...srcVal[INCLUDE]]\n        : srcVal[INCLUDE];\n  }\n\n  // if objVal doesn't exists create new from source\n  if (_.isUndefined(newObjVal) && _.isPlainObject(srcVal)) {\n    // Copy symbol fix.\n    // { ...srcVal } copies symbol wrong, it adds symbol value to the property defined just after it\n    // Problem example: { SYMBOL: ['Test'], someProp: 10 } => { someProp: ['Test'] }\n    // mergeWith prevents wrong copy because it doesn't iterate trough Symbols so it skips INCLUDE\n    // We do not INCLUDE symbol to be copied actually in this function\n    // because it is copied manually. This whole function is fixing Symbol problems.\n    const newObj = _.mergeWith({}, srcVal, (o, s) => s);\n    // Assigning INCLUDE after object definition to avoid Object.assign when code transpiled.\n    // Object.assign in RN uses polyfill which doesn't copy Symbols that's why INCLUDE symbol\n    // must be set manually after spread.\n    // TODO(Braco) - once Object.assign polyfill is no longer used use commented code bellow\n    // Check if `customizer` is needed still at all after polyfill is removed!\n    // return { ...srcVal, [INCLUDE]: include }; // add new lines for each property\n    if (include) {\n      newObj[INCLUDE] = include;\n    }\n    return newObj;\n  }\n\n  // otherwise let lodash default merge (return undefined)\n  // and add INCLUDE to objVal if any in srcVal\n  if (_.isPlainObject(newObjVal) && include) {\n    newObjVal[INCLUDE] = include;\n  }\n}\n\n/**\n * Recursively include required target styles from target and base root.\n *\n * @param target - styles object containing\n * @param base - additional style object from which target may include style\n */\nexport default function resolveIncludes(target, base = {}) {\n  /**\n   * Include process steps:\n   * 1. Iterate through target object, check if property is object and if it has [INCLUDE]\n   * 2.a. If property is object, repeat process for that object\n   * 2.b. If property is not object leave value as is\n   * 3. Include any [INCLUDE] (required style)\n   *  1. Repeat process for required style (check if it has any [INCLUDE])\n   */\n\n  /**\n   * Merges style from target and base.\n   * Target style overrides base.\n   * @param styleName - style name to include\n   */\n  function getStyle(styleName) {\n    const defaultStyle = {};\n    let style = defaultStyle;\n\n    const baseStyle = base[styleName];\n    if (baseStyle) {\n      if (baseStyle[INCLUDE]) {\n        throw Error(\n          `Base style cannot have includes, unexpected include in ${styleName}.`,\n        );\n      }\n      style = {...baseStyle};\n    }\n\n    const targetStyle = target[styleName];\n    if (targetStyle) {\n      style = {\n        ...style,\n        ...targetStyle,\n      };\n    }\n\n    if (style === defaultStyle) {\n      console.warn(`Including unexisting style: ${styleName}`);\n    }\n\n    return style;\n  }\n\n  // Includes all styles required by using the INCLUDE symbol\n  // on the styleNode object level, and recursively calls itself\n  // for all nested style objects. After calling this function, the\n  // styleNode object will be fully processed, i.e., all styles\n  // required by this object, and any of its children will be resolved.\n  function includeNodeStyles(styleNode, processingStyleNames) {\n    if (!_.isPlainObject(styleNode)) {\n      return styleNode;\n    }\n\n    // Style names which current style node want to include\n    const styleNamesToInclude = styleNode[INCLUDE];\n\n    let stylesToInclude = {};\n    if (styleNamesToInclude) {\n      if (!_.isArray(styleNamesToInclude)) {\n        throw Error('Include should be array');\n      }\n\n      for (const styleName of styleNamesToInclude) {\n        if (processingStyleNames.has(styleName)) {\n          throw Error(`Circular style include, including ${styleName}`);\n        }\n        processingStyleNames.add(styleName);\n        stylesToInclude = _.mergeWith(\n          {},\n          stylesToInclude,\n          includeNodeStyles(getStyle(styleName), processingStyleNames),\n          includeSymbolMergeHandler,\n        );\n        processingStyleNames.delete(styleName);\n      }\n    }\n\n    const resultingStyle = _.mergeWith(\n      {},\n      stylesToInclude,\n      styleNode,\n      includeSymbolMergeHandler,\n    );\n    delete resultingStyle[INCLUDE];\n\n    for (const styleName of Object.keys(resultingStyle)) {\n      resultingStyle[styleName] = includeNodeStyles(\n        resultingStyle[styleName],\n        processingStyleNames,\n      );\n    }\n    return resultingStyle;\n  }\n\n  // A that holds all style names that are currently\n  // being processed. This is used to detect include\n  // cycles.\n  const processingStyleNames = new Set();\n  return includeNodeStyles(target, processingStyleNames);\n}\n"],"file":"resolveIncludes.js"}